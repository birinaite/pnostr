<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nostr Player</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            justify-content: space-between;
        }

        #mainContent {
            padding: 20px;
            flex: 1;
            overflow-y: auto;
        }

        #logContainer {
            width: 100%;
            height: 150px;
            overflow-y: scroll;
            background-color: #f0f0f0;
            padding: 10px;
            border-top: 1px solid #ccc;
            font-size: 14px;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            box-sizing: border-box;
        }

        #loading {
            font-size: 18px;
            color: #333;
        }

        #eventContent,
        #audioPlayerContainer {
            display: none;
        }

        #audioPlayerContainer {
            margin-top: 20px;
        }

        button {
            margin: 10px;
            padding: 10px;
            font-size: 16px;
        }

        h1 {
            margin-top: 0;
        }
    </style>
</head>

<body>
    <div id="mainContent">
        <h1>Nostr Player</h1>
        <p>Este script permite reprodução progressiva de áudios armazenados na rede Nostr. Ao selecionar um áudio, o player busca e carrega fragmentos em tempo real, permitindo que a música comece a tocar imediatamente.</p>


        <div>
<!--             <button onclick="startProcess('9f97f88a30ed08beefa44e72ed8e7ee3e8181c260b39e571ac86a677fc330d3c')">XITAO</button> -->
            <button onclick="startProcess('4e3dec50ca8ce23694df0a3c35c6564d0eb389326d56b189278d43e809d80a98')">DOV SENHA</button>
            <button onclick="startProcess('5e2df85f1c997589ab5975ab1873aec040e2f9c356ccd2a335c101185e44b515')">WAKA WAKA</button>
            <button onclick="startProcess('8ca06f1907a4ad761796968bf6ce7f72f7d2f2171e7bea96615c815bf50f1d4c')">TROOPER</button>
            <button onclick="startProcess('4fd0ee46f7ed68c0343a219ffa9ca479df84b6f2cb95d7f313394038d2383e37')">HOLD ON</button>
            <button onclick="startProcess('9599acc517e56c288b12a8f54c7630e1b409083353c58e309cd8c031d49da625')">PAROV/ALLNGHT</button>
            <button onclick="startProcess('0b938e7d771e96b53e57001a3d35ed22b1553372c0af534c98e3ef21a5f7a6bd')">THUNDER</button>
        </div>
        <div id="loading"></div>
        <div id="eventContent"></div>
        <div id="audioPlayerContainer">
            <audio id="audioPlayer" controls>
                Seu navegador não suporta o elemento de áudio.
            </audio>
        </div>
    </div>
    <div id="logContainer">
        <h3>Log de Acessos</h3>
        <div id="log"></div>
    </div>

    <script>
        const relayUrl = 'wss://relay.primal.net';
        let fragmentsReceived = 0;
        let totalFragments = 0;
        let eventIdsHexGlobal = [];
        let mediaSource;
        let sourceBuffer;
        let audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const FRAGMENTS_PER_CONNECTION = 1000;

        const loadingDiv = document.getElementById('loading');
        const logDiv = document.getElementById('log');
        const logContainerDiv = document.getElementById('logContainer');
        const audioPlayerContainerDiv = document.getElementById('audioPlayerContainer');
        const audioPlayer = document.getElementById('audioPlayer');

        function logMessage(message) {
            const logEntry = document.createElement('div');
            logEntry.textContent = message;
            logDiv.appendChild(logEntry);
            logContainerDiv.scrollTop = logContainerDiv.scrollHeight;
        }

        async function fetchPostContent(postId) {
            logMessage(`Conectando ao relay ${relayUrl} para obter o conteúdo do post ID: ${postId}`);
            const eventIdsHex = await fetchEventIds(postId);
            if (eventIdsHex.length > 0) {
                totalFragments = eventIdsHex.length;
                eventIdsHexGlobal = eventIdsHex;
                initializeMediaSource();
                await processEvents();
            } else {
                logMessage("Nenhum evento encontrado.");
                loadingDiv.style.display = 'none';
            }
        }

        async function fetchEventIds(postId) {
            return new Promise((resolve, reject) => {
                const ws = new WebSocket(relayUrl);
                const subscriptionId = 'sub_' + Date.now();

                ws.onopen = function () {
                    logMessage(`Conexão aberta para obter IDs de eventos.`);
                    const reqMessage = ["REQ", subscriptionId, { "ids": [postId] }];
                    ws.send(JSON.stringify(reqMessage));
                };

                ws.onmessage = function (event) {
                    try {
                        const data = JSON.parse(event.data);
                        if (data[0] === "EVENT" && data[1] === subscriptionId) {
                            const content = JSON.parse(data[2].content);
                            if (content.fragment_ids) {
                                const eventIdsHex = content.fragment_ids;
                                logMessage(`IDs de eventos recebidos: ${eventIdsHex.length}`);
                                resolve(eventIdsHex);
                            } else {
                                resolve([]);
                            }
                            ws.close();
                        }
                    } catch (error) {
                        //logMessage('Erro ao processar a mensagem recebida: ' + error.message);
                        reject(error);
                    }
                };

                ws.onerror = function (err) {
                    logMessage('Erro na conexão');
                    reject(err);
                };

                ws.onclose = function () {
                    logMessage('Conexão fechada');
                };
            });
        }

        function initializeMediaSource() {
            mediaSource = new MediaSource();
            audioPlayer.src = URL.createObjectURL(mediaSource);

            mediaSource.addEventListener('sourceopen', () => {
                sourceBuffer = mediaSource.addSourceBuffer('audio/mpeg');
                sourceBuffer.mode = 'sequence';
                audioPlayerContainerDiv.style.display = 'block';
                logMessage('MediaSource inicializado e SourceBuffer adicionado.');
            });

            audioPlayer.addEventListener('canplay', () => {
                logMessage('Reprodução de áudio iniciada.');
                audioPlayer.play();
            });

            audioPlayer.addEventListener('seeking', (event) => {
                const currentTime = audioPlayer.currentTime;

                // Verifica se a posição do buffer já contém dados suficientes
                if (!sourceBuffer || sourceBuffer.buffered.length === 0 || currentTime > sourceBuffer.buffered.end(0)) {
                    event.preventDefault();
                    logMessage('Não é possível pular, os fragmentos ainda não foram carregados.');
                    audioPlayer.currentTime = sourceBuffer.buffered.end(0) - 0.5; // Mova para a última posição carregada
                }
            });
        }

        async function processEvents(startIndex = 0) {
            return new Promise((resolve, reject) => {
                const ws = new WebSocket(relayUrl);
                const subscriptionId = 'sub_' + Date.now();
                let timeoutHandle;

                ws.onopen = function () {
                    logMessage(`Processando eventos a partir do índice ${startIndex}`);
                    for (let i = startIndex; i < eventIdsHexGlobal.length && i < startIndex + FRAGMENTS_PER_CONNECTION; i++) {
                        const eventIdHex = eventIdsHexGlobal[i];
                        const reqMessage = ["REQ", subscriptionId, { "ids": [eventIdHex] }];
                        ws.send(JSON.stringify(reqMessage));
                    }

                    timeoutHandle = setTimeout(() => {
                        if (fragmentsReceived < totalFragments) {
                            logMessage(`Timeout atingido. Fragmentos recebidos: ${fragmentsReceived}/${totalFragments}`);
                            ws.close();
                        }
                    }, 3000);
                };

                ws.onmessage = function (event) {
                    try {
                        const data = JSON.parse(event.data);
                        if (data[0] === "EVENT" && data[1] === subscriptionId) {
                            const content = JSON.parse(data[2].content);
                            if (content.part) {
                                const audioData = atob(content.part);
                                const audioBuffer = new Uint8Array(audioData.length);
                                for (let i = 0; i < audioData.length; i++) {
                                    audioBuffer[i] = audioData.charCodeAt(i);
                                }
                                appendBuffer(audioBuffer);
                                fragmentsReceived++;
                                logMessage(`Parte do áudio adicionada. Fragmentos recebidos: ${fragmentsReceived}/${totalFragments}`);
                                if (fragmentsReceived === totalFragments) {
                                    clearTimeout(timeoutHandle);
                                    ws.close();
                                    mediaSource.endOfStream();
                                    resolve();
                                }
                            }
                        }
                    } catch (error) {
                        //logMessage('Erro ao processar a mensagem recebida: ' + error.message);
                        reject(error);
                    }
                };

                ws.onerror = function (err) {
                    logMessage('Erro na conexão');
                    clearTimeout(timeoutHandle);
                    reject(err);
                };

                ws.onclose = function () {
                    clearTimeout(timeoutHandle);
                    logMessage('Conexão fechada após processar eventos.');
                    if (fragmentsReceived < totalFragments) {
                        logMessage("Reconectando para continuar o processamento...");
                        processEvents(fragmentsReceived).then(resolve).catch(reject);
                    } else {
                        resolve();
                    }
                };
            });
        }

        function appendBuffer(buffer) {
            if (sourceBuffer && !sourceBuffer.updating) {
                sourceBuffer.appendBuffer(buffer);
                logMessage("Buffer adicionado ao SourceBuffer.");
            } else {
                setTimeout(() => appendBuffer(buffer), 100);
            }
        }

        function startProcess(postId) {
            logDiv.innerHTML = '';
            loadingDiv.style.display = 'block';
            audioPlayerContainerDiv.style.display = 'none';
            fragmentsReceived = 0;
            totalFragments = 0;
            eventIdsHexGlobal = [];
            logMessage(`Iniciando processo para o post ID: ${postId}`);
            fetchPostContent(postId);
        }
    </script>
</body>

</html>
