<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nostr Player</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            justify-content: space-between;
        }
        #mainContent {
            padding: 20px;
            flex: 1;
            overflow-y: auto;
        }
        #logContainer {
            width: 100%;
            height: 150px;
            overflow-y: scroll;
            background-color: #f0f0f0;
            padding: 10px;
            border-top: 1px solid #ccc;
            font-size: 14px;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            box-sizing: border-box;
        }
        #loading {
            font-size: 18px;
            color: #333;
        }
        #eventContent, #audioPlayerContainer {
            display: none;
        }
        #audioPlayerContainer {
            margin-top: 20px;
        }
        button {
            margin: 10px;
            padding: 10px;
            font-size: 16px;
        }
        h1 {
            margin-top: 0;
        }
    </style>
</head>
<body>
    <div id="mainContent">
        <h1>Nostr Player</h1>
        <p>Este script permite que você carregue e reproduza áudios armazenados no Nostr, utilizando IDs de eventos específicos. Ao clicar em um botão, o script recupera o conteúdo do áudio em partes, recompõe o arquivo e o reproduz no seu navegador.</p>
        
        <div>
            <button onclick="startProcess('2273f05320f2e4112d96487f0489afcf38ee4b53a2d4899fc601d581537a9577')">Risada do Dov</button>
            <button onclick="startProcess('93d127b38e3644ec66577d2645e369f90c6327bdb5eefe77badd23d650240c71')">Bom dia Guerreiros</button>
            <button onclick="startProcess('535a4ee07e85c105110237ad1d7576d7f9b9b2b34c76af6b0ecc3fe9ae70323b')">Bruce Its Time!</button>
            <button onclick="startProcess('eb8a2ed11883f00e5cf3500becd22d6ee43dbb13097f6cbfe03319c7588848d9')">You got a beard!</button>
            <button onclick="startProcess('7d06b01fed043623cf13e38bf6eae8bda0aeaba2d338be412b8e61d5347c3a8d')">Frankie Bitcoin</button>
            <button onclick="startProcess('0926eebe6996278555719d1489201bd360ab42a0aae6905f4a80cb3b191b13c5')">Saylor no 2nd best Bitcoin</button>
            <button onclick="startProcess('612de6b81084c22cdead847f1d3375d74e636cc76c76274e1377f86f2f5c6224')">HFSP</button>
            <button onclick="startProcess('50e055101d5b3ccf6aa096fcf1220132142275b762350307bc175ca83216921b')">TAKITA</button>
            <button onclick="startProcess('e59a4989c9210514e44b56a540a5dbf421c8ad99502f5523c77bd88a27c6a44b')">ROSES</button>
        </div>
        <div id="loading"></div>
        <div id="eventContent"></div>
        <div id="audioPlayerContainer">
            <audio id="audioPlayer" controls>
                Seu navegador não suporta o elemento de áudio.
            </audio>
        </div>
    </div>
    <div id="logContainer">
        <h3>Log de Acessos</h3>
        <div id="log"></div>
    </div>

    <script>
        const relayUrl = 'wss://relay.primal.net';
        let combinedPartContent = '';  
        let fragmentsReceived = 0;
        let totalFragments = 0;
        let eventIdsHexGlobal = [];
        const FRAGMENTS_PER_CONNECTION = 1000;  // Limite de fragmentos por conexão

        const loadingDiv = document.getElementById('loading');
        const logDiv = document.getElementById('log');
        const logContainerDiv = document.getElementById('logContainer');
        const audioPlayerContainerDiv = document.getElementById('audioPlayerContainer');

        function logMessage(message) {
            const logEntry = document.createElement('div');
            logEntry.textContent = message;
            logDiv.appendChild(logEntry);
            logContainerDiv.scrollTop = logContainerDiv.scrollHeight;
        }

        async function fetchPostContent(postId) {
            logMessage(`Conectando ao relay ${relayUrl} para obter o conteúdo do post ID: ${postId}`);
            const eventIdsHex = await fetchEventIds(postId);
            if (eventIdsHex.length > 0) {
                totalFragments = eventIdsHex.length;
                eventIdsHexGlobal = eventIdsHex;  // Guardando globalmente para reuso em reconexões
                await processEvents();
                logMessage(`Conteúdo final Base64: ${combinedPartContent.length} caracteres`);
                createAudioPlayer(combinedPartContent);
            } else {
                logMessage("Nenhum evento encontrado.");
                loadingDiv.style.display = 'none';
            }
        }

        async function fetchEventIds(postId) {
            return new Promise((resolve, reject) => {
                const ws = new WebSocket(relayUrl);
                const subscriptionId = 'sub_' + Date.now();

                ws.onopen = function() {
                    logMessage(`Conexão aberta para obter IDs de eventos.`);
                    const reqMessage = ["REQ", subscriptionId, { "ids": [postId] }];
                    ws.send(JSON.stringify(reqMessage));
                };

                ws.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        if (data[0] === "EVENT" && data[1] === subscriptionId) {
                            const content = data[2].content;
                            const eventIdsHex = content.split('|');
                            logMessage(`IDs de eventos recebidos: ${eventIdsHex.length}`);
                            resolve(eventIdsHex);
                            ws.close();
                        }
                    } catch (error) {
                        logMessage('Erro ao processar a mensagem recebida: ' + error.message);
                        reject(error);
                    }
                };

                ws.onerror = function(err) {
                    logMessage('Erro na conexão');
                    reject(err);
                };

                ws.onclose = function() {
                    logMessage('Conexão fechada');
                };
            });
        }

        async function processEvents(startIndex = 0) {
            return new Promise((resolve, reject) => {
                const ws = new WebSocket(relayUrl);
                const subscriptionId = 'sub_' + Date.now();
                let timeoutHandle;

                ws.onopen = function() {
                    logMessage(`Processando eventos a partir do índice ${startIndex}`);
                    for (let i = startIndex; i < eventIdsHexGlobal.length && i < startIndex + FRAGMENTS_PER_CONNECTION; i++) {
                        const eventIdHex = eventIdsHexGlobal[i];
                        const reqMessage = ["REQ", subscriptionId, { "ids": [eventIdHex] }];
                        ws.send(JSON.stringify(reqMessage));
                    }

                    // Timeout de 3 segundos para detectar inatividade e fechar a conexão
                    timeoutHandle = setTimeout(() => {
                        if (fragmentsReceived < totalFragments) {
                            logMessage(`Timeout atingido. Fragmentos recebidos: ${fragmentsReceived}/${totalFragments}`);
                            ws.close();
                        }
                    }, 3000); // Timeout de 3 segundos
                };

                ws.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        if (data[0] === "EVENT" && data[1] === subscriptionId) {
                            const content = JSON.parse(data[2].content);
                            if (content.part) {
                                combinedPartContent += content.part;
                                fragmentsReceived++;
                                logMessage(`Parte do áudio adicionada. Fragmentos recebidos: ${fragmentsReceived}/${totalFragments}`);
                            }
                            if (fragmentsReceived % FRAGMENTS_PER_CONNECTION === 0 || fragmentsReceived === totalFragments) {
                                clearTimeout(timeoutHandle);
                                logMessage("Rotacionando a conexão...");
                                ws.close();
                            }
                        }
                    } catch (error) {
                        logMessage('Erro ao processar a mensagem recebida: ' + error.message);
                        reject(error);
                    }
                };

                ws.onerror = function(err) {
                    logMessage('Erro na conexão');
                    clearTimeout(timeoutHandle);
                    reject(err);
                };

                ws.onclose = function() {
                    clearTimeout(timeoutHandle);
                    logMessage('Conexão fechada após processar eventos.');
                    if (fragmentsReceived < totalFragments) {
                        logMessage("Reconectando para continuar o processamento...");
                        processEvents(fragmentsReceived).then(resolve).catch(reject);
                    } else {
                        resolve();
                    }
                };
            });
        }

        function getMimeTypeFromBlob(base64) {
            const binary = atob(base64.split(',')[1] || base64);
            const byteNumbers = new Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                byteNumbers[i] = binary.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            const blob = new Blob([byteArray]);
            return blob.type || 'application/octet-stream';
        }

        function createAudioPlayer(base64String) {
            try {
                if (!base64String || base64String.length === 0) {
                    throw new Error("Conteúdo base64 vazio ou inválido.");
                }

                logMessage("Iniciando criação do player de áudio...");

                // Limpa e prepara a string Base64
                base64String = base64String.split(',')[1] || base64String;
                base64String = base64String.replace(/[^A-Za-z0-9+/=]/g, '');

                const mimeType = getMimeTypeFromBlob(base64String);
                logMessage(`Tipo MIME identificado: ${mimeType}`);

                const byteCharacters = atob(base64String);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }

                const byteArray = new Uint8Array(byteNumbers);
                logMessage("Array de bytes criado com sucesso.");

                // Cria o Blob com um tipo MIME genérico se não for possível identificar
                const blob = new Blob([byteArray], { type: mimeType !== 'application/octet-stream' ? mimeType : 'audio/mp3' });
                const blobURL = URL.createObjectURL(blob);
                const audioPlayer = document.getElementById('audioPlayer');
                audioPlayer.src = blobURL;

                logMessage("Player de áudio criado com sucesso!");

                loadingDiv.style.display = 'none';
                audioPlayerContainerDiv.style.display = 'block';
                audioPlayer.play();
                logMessage("Reprodução de áudio iniciada.");
            } catch (error) {
                logMessage("Erro ao criar o player de áudio: " + error.message);
                loadingDiv.textContent = 'Erro ao criar o player de áudio';
            }
        }

        function startProcess(postId) {
            logDiv.innerHTML = ''; 
            loadingDiv.style.display = 'block';
            audioPlayerContainerDiv.style.display = 'none';
            loadingDiv.textContent = 'Carregando...';
            combinedPartContent = '';
            fragmentsReceived = 0;
            totalFragments = 0;
            eventIdsHexGlobal = [];
            logMessage(`Iniciando processo para o post ID: ${postId}`);
            fetchPostContent(postId);
        }
    </script>
</body>
</html>
